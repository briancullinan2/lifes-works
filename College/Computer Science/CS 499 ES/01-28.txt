1/28
8, MHZ, 16 MHZ - max clock frequency

static logic
 - extra extra overhead to make sure opps happen irregardless of clock
 - p type transistors


dynamic logic - clocked logic
2 x faster
 - n type transistors


16 registers
16 bits
Risc, 27 instructions / opps
12 registers gp -> R4...r15


R0 - PC
R1 - SP

Funcion call
jmp to subroutine
r0 = <subroutine address>
exit subroutine

R2 status register (flags)
C - carry flag
Z - zero flag
N - Negative
V - 
GIE - Enable maskable interups
CPUOFF 
OSCOFF
SCG
SCG1

R3 Constant generator
changes based on how you address it

r4-r15
peripherals are memory mapped - access just like memory
P1IN <- read only + volatile
P1OUT <- Read/write only effects hw if P1 DIR


Two flow control exceptions
1) interrupts 
	generated by hardware, (sometimes sw)
	says event has occurred and needs a response
	1) stores pc + sp
	2) Executes a new routine
	  ISR - Interrupt service routine
	3) when complete restore pc + sr 
-------------
	unsuspend
2) reset


PIC16 - 1 for each
	0x0000 -> resets
	0x0004 -> interrupts

ARM7TDMI 

MSP430 - Vectored interrupts
Each ISR gets a vector 

Ex
0xFFF4 <- watchdog timer
0xFFFE <- reset / start

C compiler were using does support C90
C99 parts
EC++ std
extensions
	@address of a variable
	doesnt suppor 0b101010
	instrinsic functions
		__enable_interrupt();
*********** MISRA c checking  
